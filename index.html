<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Voxel 3D — ブラウザで遊べる簡易マイクラ風</title>
  <style>
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN',Meiryo}
    #ui{position:fixed;left:12px;top:12px;z-index:10;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px}
    #palette button{margin:2px;padding:6px;border-radius:6px;border:1px solid #888;cursor:pointer}
    #info{position:fixed;left:12px;bottom:12px;z-index:10;background:rgba(0,0,0,0.6);color:#fff;padding:8px;border-radius:6px}
    canvas{display:block}
  </style>
</head>
<body>
  <div id="ui">
    <div><strong>Voxel 3D — 簡易マイクラ風</strong></div>
    <div id="palette">Block: <button data-color="#8B4513" style="background:#8B4513;">土</button><button data-color="#228B22" style="background:#228B22;">草</button><button data-color="#c2b280" style="background:#c2b280;">砂</button><button data-color="#808080" style="background:#808080;">石</button></div>
    <div style="margin-top:6px"><button id="save">Save</button> <button id="load">Load</button> <button id="clear">Clear</button></div>
  </div>
  <div id="info">Left click: remove / Right click: place · Scroll: zoom · Drag: rotate</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.1/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.150.1/examples/jsm/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(20,20,30);

    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight); document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,2,0);
    controls.update();

    window.addEventListener('resize', ()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)});

    // lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9); scene.add(hemi);
    const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(10,20,10); scene.add(dir);

    // grid helper
    const grid = new THREE.GridHelper(60,60,'#666','#333'); scene.add(grid);

    // voxel data structure
    const voxels = new Map(); // key 'x,y,z' -> color
    const cubeSize = 1;

    function key(x,y,z){return `${x},${y},${z}`}

    // materials cache
    const materials = {};
    function mat(color){ if(materials[color]) return materials[color]; const m = new THREE.MeshStandardMaterial({color}); materials[color]=m; return m }

    // geometry to reuse
    const boxGeo = new THREE.BoxGeometry(cubeSize,cubeSize,cubeSize);

    // group for blocks
    const blocksGroup = new THREE.Group(); scene.add(blocksGroup);

    // helper hover cube
    const hoverMat = new THREE.MeshBasicMaterial({color:0xffffff,opacity:0.6,transparent:true});
    const hoverMesh = new THREE.Mesh(boxGeo, hoverMat); hoverMesh.visible=false; scene.add(hoverMesh);

    // initial flat ground
    const R = 12;
    for(let x=-R;x<=R;x++) for(let z=-R;z<=R;z++) setVoxel(x,0,z,'#8B4513');
    // add some grass on top
    for(let x=-R;x<=R;x+=2) for(let z=-R;z<=R;z+=2) if(Math.random()<0.5) setVoxel(x,1,z,'#228B22');

    // render voxel meshes from voxels map
    function rebuildVoxels(){ blocksGroup.clear(); for(const [k,c] of voxels.entries()){ const [x,y,z]=k.split(',').map(Number); const m = new THREE.Mesh(boxGeo, mat(c)); m.position.set(x,y,z); blocksGroup.add(m);} }

    function setVoxel(x,y,z,color){ voxels.set(key(x,y,z), color); }
    function removeVoxel(x,y,z){ voxels.delete(key(x,y,z)); }

    // initial rebuild performed already
    rebuildVoxels();

    // raycaster for mouse
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function getIntersect(){ raycaster.setFromCamera(pointer, camera); const intersects = raycaster.intersectObjects(blocksGroup.children, false); return intersects[0] || null }

    // mouse events
    let selectedColor = '#8B4513';
    document.getElementById('palette').addEventListener('click', e=>{ const b = e.target.closest('button'); if(!b) return; selectedColor = b.dataset.color; });

    renderer.domElement.addEventListener('contextmenu', e=>e.preventDefault());

    renderer.domElement.addEventListener('pointermove', e=>{
      pointer.x = (e.clientX / innerWidth) * 2 - 1;
      pointer.y = - (e.clientY / innerHeight) * 2 + 1;
      const hit = getIntersect();
      if(hit){
        // position hover cube on face
        const p = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5));
        const gx = Math.round(p.x), gy = Math.round(p.y), gz = Math.round(p.z);
        hoverMesh.position.set(gx,gy,gz);
        hoverMesh.visible = true;
      } else { hoverMesh.visible = false; }
    });

    renderer.domElement.addEventListener('pointerdown', e=>{
      pointer.x = (e.clientX / innerWidth) * 2 - 1;
      pointer.y = - (e.clientY / innerHeight) * 2 + 1;
      const hit = getIntersect();
      if(e.button === 0){ // left -> remove block
        if(hit){ const pos = hit.object.position; removeVoxel(pos.x,pos.y,pos.z); rebuildVoxels(); }
      } else if(e.button === 2){ // right -> place block on face
        if(hit){ const p = hit.point.clone().add(hit.face.normal.clone().multiplyScalar(0.5)); const gx = Math.round(p.x), gy = Math.round(p.y), gz = Math.round(p.z); setVoxel(gx,gy,gz,selectedColor); rebuildVoxels(); }
      }
    });

    // simple save/load
    document.getElementById('save').addEventListener('click', ()=>{ localStorage.setItem('voxels', JSON.stringify(Array.from(voxels.entries()))); alert('Saved to localStorage.'); });
    document.getElementById('load').addEventListener('click', ()=>{ const data = localStorage.getItem('voxels'); if(!data) return alert('No saved data.'); voxels.clear(); const arr = JSON.parse(data); for(const [k,v] of arr) voxels.set(k,v); rebuildVoxels(); });
    document.getElementById('clear').addEventListener('click', ()=>{ if(!confirm('Clear all?')) return; voxels.clear(); rebuildVoxels(); });

    // animate
    function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); }
    animate();

  </script>
</body>
</html>
